(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Code:: *)
Int[a_,x_Symbol] :=
   a*x /;
FreeQ[a,x]


(* ::Code:: *)
Int[u_,x_Symbol] :=
  Map[Function[Int[#,x]],u] /;
Head[u]===Plus


(* ::Code:: *)
Int[a_*u_,x_Symbol] :=
  Dist[a,Int[u,x]] /;
FreeQ[a,x] && Not[MatchQ[u,b_*v_. /; FreeQ[b,x]]]


(* ::Code:: *)
Int[x_^n_.,x_Symbol] :=
  x^(n+1)/(n+1) /;
RationalQ[n] && n!=-1


(* ::Code:: *)
SumQ[u_] :=
  Head[u]===Plus


(* ::Code:: *)
ProductQ[u_] :=
  Head[u]===Times


(* ::Code:: *)
RationalQ[u_] :=
  If[ListQ[u],
    Catch[Scan[Function[If[Not[RationalQ[#]],Throw[False]]],u]; True],
  IntegerQ[u] || Head[u]===Rational]


(* ::Code:: *)
(* RealNumericQ[u] returns True if u is a real numeric quantity, else returns False. *)
RealNumericQ[u_] := NumericQ[u] && PossibleZeroQ[Im[N[u]]]


(* ::Code:: *)
(* PositiveQ[u] returns True if u is a positive numeric quantity, else returns False. *)
PositiveQ[u_] :=
  Module[{v=Together[u]},
  RealNumericQ[v] && Re[N[v]]>0]


(* ::Code:: *)
(* NegativeQ[u] returns True if u is a negative numeric quantity, else returns False. *)
NegativeQ[u_] :=
  Module[{v=Together[u]},
  RealNumericQ[v] && Re[N[v]]<0]


(* ::Code:: *)
(* ZeroQ[u] returns True if u is any 0; else returns False *)
ZeroQ[u_] := PossibleZeroQ[u]


(* ::Code:: *)
(* NonzeroQ[u] returns True if u is not any 0, else it returns False. *)
NonzeroQ[u_] := Not[PossibleZeroQ[u]]


(* ::Code:: *)
(* Dist[u,v] distributes u over the terms of v. *) 
Dist[u_,v_] := 
  If[SumQ[v],
    Map[Function[Dist[u,#]],v],
  u*v]


(* ::Code:: *)
Rt[u_,n_Integer] := u^(1/n)


(* ::Code:: *)
(* If u is not 0 and has a positive form, PosQ[u] returns True, else it returns False. *)
PosQ[u_] :=
  If[RationalQ[u],
    u>0,
  If[NumberQ[u],
    If[PossibleZeroQ[Re[u]],
      Im[u]>0,
    Re[u]>0],
  If[NumericQ[u],
    Module[{v=N[u]},
    If[PossibleZeroQ[Re[v]],
      Im[v]>0,
    Re[v]>0]],
  If[ProductQ[u],
    If[PosQ[First[u]],
      PosQ[Rest[u]],
    NegQ[Rest[u]]],
  If[SumQ[u],
    Module[{v=Together[u]},
    If[SumQ[v],
      PosQ[First[v]],
    PosQ[v]]],
  True]]]]]


(* ::Code:: *)
NegQ[u_] :=
  If[PossibleZeroQ[u],
    False,
  Not[PosQ[u]]]


(* ::Code:: *)
Sim[u_] := Together[u];

Sim[u_,x_] := 
  If[SumQ[u],
    Module[{tmp1=0,tmp2=0,lst},
    Scan[Function[lst=SplitFreeFactors[#,x];If[lst[[2]]===1,tmp1+=#,tmp2=tmp2+Together[lst[[1]]]*lst[[2]]]],u];
    Together[tmp1]+tmp2],
  Module[{lst=SplitFreeFactors[u,x]},
  Together[lst[[1]]]*lst[[2]]]]


(* ::Code:: *)
(* SplitFreeFactors[u,x] returns the list {v,w} where v is the product of the factors of u free of x
	and w is the product of the other factors. *)
SplitFreeFactors[u_,x_Symbol] :=
  If[ProductQ[u],
    Map[Function[If[FreeQ[#,x],{#,1},{1,#}]],u],
  If[FreeQ[u,x],
    {u,1},
  {1,u}]]
